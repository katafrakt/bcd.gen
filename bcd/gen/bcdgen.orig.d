/**
 * Generate bindings for C[++] in D
 * 
 * Authors: Gregor Richards
 * 
 * License:
 *  Copyright (C) 2006  Gregor Richards
 *  
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

module bcd.gen.bcdgen;

private import std.file;
private import std.path;
private import std.process;
private import std.stdio;
private import std.string;

private import bcd.gen.libxml2;

extern (C) char* getenv(immutable(char)*);

// some global variables (yay)
/** The full path to the current file */
char[] curFile;
/** The include prefix */
char[] incPrefix;
/** The base directory of .h files */
char[] baseDir;
/** The short name of the current .h file (no basename, no .h) */
char[] shortName;
/** The D namespace */
char[] dNamespace;
/** The C++ functions/variables to explicitly ignore */
char[][] ignoreSyms;
/** The D output */
char[] dhead;
char[] dtail;
/** The C[++] output */
char[] cout;
char[] curClass;
/** Should we output C instead of C++ */
bool outputC;
/** Should we output symbols provided by any header in the dir? */
bool outputAll;
/** Other BCD requirements */
char[][char[]] reqDependencies;

char[][char[]] files;


int main(char[][] args)
{
    if (args.length < 3) {
        writefln("Use:");
        writefln("bcdgen <.h file> <D namespace> [options]");
        writefln("Options:");
        writefln("  -I<include prefix>");
        writefln("  -N<symbol to ignore>");
        writefln("  -C");
        writefln("    Read/write C instead of C++");
        writefln("  -R<include directory>=<BCD/D namespace>");
        writefln("    Depend upon other BCD namespaces.");
        writefln("  -A");
        writefln("    Include all symbols provided by headers in the same");
        writefln("    directory as the provided one, regardless of whether");
        writefln("    they are actually provded by the included file.");
        writefln("  -F<forced import>");
        return 1;
    }
    
    char[] forcedImport;
    
    // set the globals
    curFile = args[1];
    baseDir = dirName(args[1]);
    shortName = baseName(args[1]);
    if (find(shortName, '.') != -1) {
        shortName = getName(shortName);
    }
    shortName = safeName(shortName);
    
    // parse other options
    for (int i = 3; i < args.length; i++) {
        if (args[i][0..2] == "-I") {
            incPrefix = args[i][2..args[i].length];
        } else if (args[i][0..2] == "-N") {
            ignoreSyms ~= args[i][2..args[i].length];
        } else if (args[i] == "-C") {
            outputC = true;
        } else if (args[i][0..2] == "-R") {
            char[] req = args[i][2..args[i].length];
            int eqloc = find(req, '=');
            if (eqloc == -1) {
                writefln("Argument %s not recognized.", args[i]);
                continue;
            }
            reqDependencies[req[0..eqloc]] = req[eqloc + 1 .. req.length];
        } else if (args[i] == "-A") {
            outputAll = true;
        } else if (args[i][0..2] == "-F") {
            forcedImport ~= "import " ~ args[i][2..args[i].length] ~ ";\n";
        } else {
            writefln("Argument %s not recognized.", args[i]);
        }
    }
    
    // the header to attach to all generated files
    const char[] genhead = "/* THIS FILE GENERATED BY bcd.gen */\n";
    
    dNamespace = args[2];
    
    // some buffers
    dhead = genhead; // the D header (extern (C)'s)
    dhead ~= "module bcd." ~ dNamespace ~ "." ~ shortName ~ ";\n";
    if (!outputC) dhead ~= "import bcd.bind;\n";
    dhead ~= forcedImport;
    dhead ~= "extern (C) void free(void *);\n";
    
    cout = genhead; // the C++ output (to name.cc)
    cout ~= "#include <stdlib.h>\n";
    cout ~= "#include <string.h>\n";
    cout ~= "#include \"" ~ incPrefix ~ baseName(args[1]) ~ "\"\n";
    if (!outputC) cout ~= "extern \"C\" {\n";
    
    // make the directories
    try {
        mkdir("bcd");
    } catch (FileException e) {} // ignore errors
    try {
        mkdir("bcd/" ~ dNamespace);
    } catch (FileException e) {} // ignore errors
    
    // xml-ize it
    if (system("gccxml " ~ toString(getenv(outputC ? "CFLAGS" : "CXXFLAGS")) ~ " -fxml=out.xml " ~ args[1])) {
        return 2;
    }
    
    // then initialize libxml2
    xmlDoc *doc = null;
    xmlNode *rootElement = null;
    
    xmlCheckVersion(20621); // the version bcdgen's XML was ported from
    
    // and read it in
    doc = xmlReadFile("out.xml", null, 0);
    
    if (doc == null) {
        writefln("Failed to parse the GCCXML-produced XML file!");
        return 3;
    }
    
    // Get the root element node
    rootElement = xmlDocGetRootElement(doc);

    parse_XML(rootElement);
    
    if (!outputC) cout ~= "}\n";
    
    write("bcd/" ~ dNamespace ~ "/" ~ shortName ~ ".d",
          dhead ~ dtail);
    if (!outputC) {
        write("bcd/" ~ dNamespace ~ "/" ~ shortName ~ ".cc",
              cout);
    }
    
    return 0;
}

/**
 * Return a name that doesn't stomp on any D keywords
 */
char[] safeName(char[] name)
{
    char[] ret = name[0..name.length];
    if (name == "alias" ||
        name == "align" ||
        name == "body" ||
        name == "function" ||
        name == "in" ||
        name == "inout" ||
        name == "module" ||
        name == "out" ||
        name == "override" ||
        name == "scope" ||
        name == "version") {
        ret ~= "_";
    }
    
    ret = replace(ret, ".", "_");
    ret = replace(ret, "-", "_");
    
    return ret;
}

/**
 * Return name unless it's anonymous, in which case return mangled
 */
char[] getNName(xmlNode *node)
{
    char[] name = toString(xmlGetProp(node, "name"));
    if (name == "") name = safeName(toString(xmlGetProp(node, "mangled")));
    return name;
}

/**
 * Return mangled unless it's not mangled
 */
char *getMangled(xmlNode *node)
{
    char *mangled = xmlGetProp(node, "mangled");
    if (!mangled && outputC) mangled = xmlGetProp(node, "name");
    return mangled;
}

/**
 * Return demangled unless it's not mangled
 */
char *getDemangled(xmlNode *node)
{
    char *demangled = xmlGetProp(node, "demangled");
    if (!demangled && outputC) demangled = xmlGetProp(node, "name");
    return demangled;
}

/**
 * Do we need to parse this node?
 */
bool parseThis(xmlNode *node)
{
    // only parse it if it's in the file we're parsing and it's demanglable
    char* file = xmlGetProp(node, "file");
    char* demangled = getDemangled(node);
    char* incomplete = xmlGetProp(node, "incomplete");
    
    if (file && demangled && !incomplete) {
        // if it's not in a file we should be parsing, don't output it
        if (outputAll) {
            if (files[toString(file)].length > baseDir.length &&
                files[toString(file)][0..baseDir.length] != baseDir) return false;
        } else {
            if (files[toString(file)] != curFile) return false;
        }
        
        // if it's builtin, don't do it
        char* name = xmlGetProp(node, "name");
        if (name) {
            char[] sname = toString(name);
            if (sname.length >= 9 &&
                toString(name)[0..9] == "__builtin") {
                return false;
            }
        }
        
        // if access is private, don't do it
        char* access = xmlGetProp(node, "access");
        if (access &&
            toString(access) != "public") {
            return false;
        }
        
        // if we were told to ignore it, do so
        char[] sdemangled = toString(demangled);
        foreach (i; ignoreSyms) {
            if (i == sdemangled) {
                return false;
            }
        }
        
        return true;
    } else {
        return false;
    }
}

/**
 * Parse the members of a node
 */
void parseMembers(xmlNode *node, xmlNode *gccxml, bool inclass, bool types)
{
    char *members = xmlGetProp(node, "members");
    if (!members) return;
    
    char[] smembers = toString(members);
    char[][] memberList = split(smembers);
    
    // parse each member in the memberList
    foreach (m; memberList) {
        parse_GCC_XML_for(gccxml, m, inclass, types);
    }
}

/**
 * Parse an XML document
 */
void parse_XML(xmlNode *node)
{
    xmlNode *curNode = null;
    
    for (curNode = node; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            // check if it's a GCC_XML
            if (toString(curNode.name) == "GCC_XML") {
                // parse this node
                parse_GCC_XML(curNode);
            }
        }
    }
}

/**
 * Parse a GCC_XML node
 */
void parse_GCC_XML(xmlNode *node)
{
    xmlNode *curNode = null;
    
    // first parse for files and fundamental types
    for (curNode = node.children; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            char[] nname = toString(curNode.name);
            
            if (nname == "File") {
                parse_File(curNode);
            }
        }
    }
    
    // then parse for namespaces, typedefs, enums (all of which can be top-level)
    for (curNode = node.children; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            char[] nname = toString(curNode.name);
            
            if (nname == "Namespace") {
                parse_Namespace(curNode);
            } else if (nname == "Typedef") {
                parse_Typedef(curNode);
            } else if (nname == "Enumeration") {
                parse_Enumeration(curNode);
            }
        }
    }
}

/**
 * Parse a GCC_XML node for a specified ID
 */
void parse_GCC_XML_for(xmlNode *node, char[] parseFor, bool inclass, bool types)
{
    xmlNode *curNode = null;
    
    for (curNode = node.children; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            char *id = xmlGetProp(curNode, "id");
            if (parseFor != toString(id)) continue;
            
            // should we even parse this?
            if (!parseThis(curNode)) continue;
            
            char[] nname = toString(curNode.name);
            
            if (nname == "Struct" || nname == "Class") {
                // structs and classes are the same in C[++]
                if (outputC) {
                    if (types) parse_Struct(curNode);
                } else {
                    if (types) parse_Class(curNode);
                }
            } else if (nname == "Union") {
                if (types) parse_Struct(curNode);
            } else if (nname == "Variable" || nname == "Field") {
                if (!types) parse_Variable(curNode, inclass);
            } else if (nname == "Method") {
                if (!types) parse_Method(curNode);
            } else if (nname == "Function") {
                if (!types) parse_Function(curNode);
            } else if (nname == "Constructor") {
                if (!types) parse_Constructor(curNode);
            } else if (nname == "Destructor") {
                // this code is automatic :)
            } else if (nname == "Typedef") {
                if (types) parse_Typedef(curNode);
            } else if (nname == "Enumeration") {
                if (types) parse_Enumeration(curNode);
            } else {
                writefln("I don't know how to parse %s!", nname);
            }
        }
    }
}

/**
 * Parse a File node
 */
void parse_File(xmlNode *node)
{
    // associate the id with the filename
    char* id, name;
    id = xmlGetProp(node, "id");
    name = xmlGetProp(node, "name");
    if (id && name) {
        char[] sname = toString(name);
        
        files[toString(id)] = sname;
        
        // import it in D
        
        // first try our own namespace
        if (dirName(sname) == baseDir) {
            char[] baseName = sname[baseDir.length + 1 .. sname.length];
            if (find(baseName, '.') != -1) {
                baseName = getName(baseName);
            }
            
            if (baseName != shortName)
                dhead ~= "import bcd." ~ dNamespace ~ "." ~ safeName(baseName) ~ ";\n";
        }
        
        // then others
        foreach (req; reqDependencies.keys) {
            if (dirName(sname) == req) {
                char[] baseName = sname[req.length + 1 .. sname.length];
                if (find(baseName, '.') != -1) {
                    baseName = getName(baseName);
                }
                
                baseName = safeName(baseName);
                
                if (baseName != shortName)
                    dhead ~= "import bcd." ~ reqDependencies[req] ~ "." ~ safeName(baseName) ~ ";\n";
            }
        }
    }
}

/**
 * Parse a Namespace node
 */
void parse_Namespace(xmlNode *node)
{
    parseMembers(node, node.parent, false, true);
    parseMembers(node, node.parent, false, false);
}

/**
 * Parse a Class or Struct node to C++
 */
void parse_Class(xmlNode *node)
{
    char[] name = getNName(node);
    char[] mangled = toString(getMangled(node));
    char[] demangled = toString(getDemangled(node));
    
    parseMembers(node, node.parent, true, true);
    
    // parse for base classes
    char[] base = "bcd.bind.BoundClass";
    xmlNode *curNode = null;
    for (curNode = node.children; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            if (toString(curNode.name) == "Base") {
                ParsedType pt = parseType(toString(xmlGetProp(curNode, "type")),
                                          node.parent);
                base = pt.DType;
                break;
            }
        }
    }
    dtail ~= "class " ~ name ~ " : " ~ base ~ " {\n";
    
    dtail ~= "this(ifloat ignore) {\n";
    dtail ~= "super(ignore);\n";
    dtail ~= "}\n";
    
    cout ~= "void _BCD_delete_" ~ mangled ~ "(" ~ demangled ~ " *This) {\n";
    cout ~= "delete This;\n";
    cout ~= "}\n";
    
    dhead ~= "extern (C) void _BCD_delete_" ~ mangled ~ "(void *);\n";
    
    dtail ~= "~this() {\n";
    dtail ~= "if (__C_data) _BCD_delete_" ~ mangled ~ "(__C_data);\n";
    dtail ~= "__C_data = null;\n";
    dtail ~= "}\n";
    
    curClass = demangled;
    
    parseMembers(node, node.parent, true, false);
    dtail ~= "}\n";
}

/**
 * Parse a Struct or Union node to C
 */
void parse_Struct(xmlNode *node)
{
    char[] type = toString(node.name);
    char[] name = getNName(node);
    char[] mangled = toString(getMangled(node));
    char[] demangled = toString(getDemangled(node));
    
    parseMembers(node, node.parent, true, true);
    
    if (type == "Union") {
        dtail ~= "union ";
    } else {
        dtail ~= "struct ";
    }
    dtail ~= name ~ " {\n";
    
    curClass = demangled;
    
    parseMembers(node, node.parent, true, false);
    dtail ~= "}\n";
}

/**
 * Parse a Variable or Field node
 */
void parse_Variable(xmlNode *node, bool inclass)
{
    char[] stype = toString(xmlGetProp(node, "type"));
    ParsedType type = parseType(stype, node.parent);
    char[] name = getNName(node);
    char[] mangled = toString(getMangled(node));
    
    if (outputC) {
        if (!inclass) {
            dtail ~= "extern (C) ";
        }
        dtail ~= type.DType ~ " " ~ safeName(name) ~ ";\n";
    } else {
        if (inclass) {
            // if it's a const, don't make the set
            if (stype[stype.length - 1] != 'c') {
                dhead ~= "extern (C) void _BCD_set_" ~ mangled ~ "(void *, " ~ type.DType ~ ");\n";
            
                dtail ~= "void set_" ~ name ~ "(" ~ type.DType ~ " x) {\n";
                dtail ~= "_BCD_set_" ~ mangled ~ "(__C_data, x);\n";
                dtail ~= "}\n";
            
                cout ~= "void _BCD_set_" ~ mangled ~ "(" ~ curClass ~ " *This, " ~ type.CType ~ " x) {\n";
                if (!type.isClass) {
                    cout ~= "This->" ~ name ~ " = x;\n";
                } else {
                    cout ~= "memcpy(&This->" ~ name ~ ", x, sizeof(" ~ type.className ~ "));\n";
                }
                cout ~= "}\n";
            }
        
            dhead ~= "extern (C) " ~ type.DType ~ " _BCD_get_" ~ mangled ~ "(void *);\n";
        
            dtail ~= type.DType ~ " get_" ~ name ~ "() {\n";
            dtail ~= "return _BCD_get_" ~ mangled ~ "(__C_data);\n";
            dtail ~= "}\n";
        
            cout ~= type.CType ~ " _BCD_get_" ~ mangled ~ "(" ~ curClass ~ " *This) {\n";
            cout ~= "return (" ~ type.CType ~ ") ";
            if (type.isClass) cout ~= "&";
            cout ~= "This->" ~ name ~ ";\n";
            cout ~= "}\n";
        } else {
            char[] demangled = toString(getDemangled(node));
        
            // if it's a const, don't make the set
            if (stype[stype.length - 1] != 'c') {
                dhead ~= "extern (C) void _BCD_set_" ~ mangled ~ "(" ~ type.DType ~ ");\n";
            
                dtail ~= "void set_" ~ name ~ "(" ~ type.DType ~ " x) {\n";
                dtail ~= "_BCD_set_" ~ mangled ~ "(x);\n";
                dtail ~= "}\n";
            
                cout ~= "void _BCD_set_" ~ mangled ~ "(" ~ type.CType ~ " x) {\n";
                if (!type.isClass) {
                    cout ~= demangled ~ " = x;\n";
                } else {
                    cout ~= "memcpy(&" ~ demangled ~ ", x, sizeof(" ~ type.className ~ "));\n";
                }
                cout ~= "}\n";
            }
        
            dhead ~= "extern (C) " ~ type.DType ~ " _BCD_get_" ~ mangled ~ "();\n";
        
            dtail ~= type.DType ~ " get_" ~ name ~ "() {\n";
            dtail ~= "return _BCD_get_" ~ mangled ~ "();\n";
            dtail ~= "}\n";
        
            cout ~= type.CType ~ " _BCD_get_" ~ mangled ~ "() {\n";
            cout ~= "return (" ~ type.CType  ~ ") ";
            if (type.isClass) cout ~= "&";
            cout ~= demangled ~ ";\n";
            cout ~= "}\n";
        }
    }
}

/**
 * Parse Argument nodes
 */
void parse_Arguments(xmlNode *node, inout char[] Dargs, inout char[] Deargs,
                     inout char[] Cargs, inout char[] Dcall,
                     inout char[] Ccall)
{
    int onParam = 0;
    xmlNode *curNode = null;
    
    for (curNode = node.children; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            char[] nname = toString(curNode.name);
            
            if (nname == "Argument") {
                ParsedType atype = parseType(toString(xmlGetProp(curNode, "type")),
                                             node.parent);
                char[] aname = getNName(curNode);
                if (aname == "") aname = "_" ~ toString(onParam);
                aname = safeName(aname);
                
                if (Dargs != "") {
                    Dargs ~= ", ";
                }
                Dargs ~= atype.DType ~ " " ~ aname;
                
                if (atype.isClass || atype.isClassPtr) {
                    // this becomes a void * in D's view
                    if (Deargs != "") {
                        Deargs ~= ", ";
                    }
                    Deargs ~= "void *" ~ aname;
                } else {
                    if (Deargs != "") {
                        Deargs ~= ", ";
                    }
                    Deargs ~= atype.DType ~ " " ~ aname;
                }
                
                if (Cargs != "") {
                    Cargs ~= ", ";
                }
                Cargs ~= atype.CType ~ " " ~ aname;
                
                if (Dcall != "") {
                    Dcall ~= ", ";
                }
                Dcall ~= aname;
                if (atype.isClass || atype.isClassPtr) {
                    // turn this into the real info
                    Dcall ~= ".__C_data";
                }
                
                if (atype.isClass) {
                    // need to dereference
                    if (Ccall != "") {
                        Ccall ~= ", ";
                    }
                    Ccall ~= "*" ~ aname;
                } else {
                    if (Ccall != "") {
                        Ccall ~= ", ";
                    }
                    Ccall ~= aname;
                }
                
            } else if (outputC && nname == "Ellipsis") {
                if (Dargs != "") {
                    Dargs ~= ", ";
                }
                Dargs ~= "...";
                
                if (Deargs != "") {
                    Deargs ~= ", ";
                }
                Deargs ~= "...";
                
                if (Cargs != "") {
                    Cargs ~= ", ";
                }
                Cargs ~= "...";
                
                if (Dcall != "") {
                    Dcall ~= ", ";
                }
                Dcall ~= "...";
                
                if (Ccall != "") {
                    Ccall ~= ", ";
                }
                Ccall ~= "...";
                
            } else {
                writefln("I don't know how to parse %s!", nname);
            }
            
            onParam++;
        }
    }
}

void parse_Function_body(xmlNode *node, char[] name, char[] mangled, char[] demangled, ParsedType type,
                         char[] Dargs, char[] Deargs, char[] Cargs, char[] Dcall, char[] Ccall)
{
    if (outputC) {
        dhead ~= "extern (C) " ~ type.DType ~ " " ~ demangled ~ "(" ~ Deargs ~ ");\n";
        return;
    }
    
    dhead ~= "extern (C) " ~ type.DType ~ " _BCD_" ~ mangled ~ "(" ~ Deargs ~ ");\n";
    
    if (!type.isClass) {
        dtail ~= type.DType ~ " " ~ name ~ "(" ~ Dargs ~ ") {\n";
        if (type.DType != "void") {
            dtail ~= "return ";
        }
        dtail ~= "_BCD_" ~ mangled ~ "(" ~ Dcall ~ ");\n";
        dtail ~= "}\n";
    
        cout ~= type.CType ~ " _BCD_" ~ mangled ~ "(" ~ Cargs ~ ") {\n";
        if (type.DType != "void") {
            cout ~= "return (" ~ type.CType ~ ") ";
        }
        cout ~= "(" ~ demangled ~ "(" ~ Ccall ~ "));\n";
        cout ~= "}\n";
    } else {
        // if it's a class, we need to dup it in C, and un-dup it in D
        dtail ~= type.DType ~ " " ~ name ~ "(" ~ Dargs ~ ") {\n";
        dtail ~= "void *cret = _BCD_" ~ mangled ~ "(" ~ Dcall ~ ");\n";
        dtail ~= type.DType ~ " dret = new " ~ type.DType ~ "(cast(ireal) 0);\n";
        dtail ~= "dret.__C_data = cret;\n";
        dtail ~= "return dret;\n";
        dtail ~= "}\n";
        
        cout ~= type.CType ~ " _BCD_" ~ mangled ~ "(" ~ Cargs ~ ") {\n";
        cout ~= "return new " ~ type.className ~ "(" ~ demangled ~ "(" ~ Ccall ~ "));\n";
        cout ~= "}\n";
    }
}

/**
 * Parse a Method node
 */
void parse_Method(xmlNode *node)
{
    char[] name = getNName(node);
    char[] mangled = toString(getMangled(node));
    ParsedType type = parseType(toString(xmlGetProp(node, "returns")),
                                node.parent);
    char[] Dargs;
    char[] Deargs = "void *This";
    char[] Cargs = curClass ~ " *This";
    char[] Dcall = "__C_data";
    char[] Ccall;
    
    parse_Arguments(node, Dargs, Deargs, Cargs, Dcall, Ccall);
    parse_Function_body(node, safeName(name), mangled, "This->" ~ name, type,
                        Dargs, Deargs, Cargs, Dcall, Ccall);
}

/**
 * Parse a Function node
 */
void parse_Function(xmlNode *node)
{
    char[] name = getNName(node);
    char[] mangled = toString(getMangled(node));
    char[] demangled = toString(getDemangled(node));
    ParsedType type = parseType(toString(xmlGetProp(node, "returns")),
                                node.parent);
    char[] Dargs;
    char[] Deargs;
    char[] Cargs;
    char[] Dcall;
    char[] Ccall;
    
    // the demangled name includes ()
    int demparen = find(demangled, '(');
    if (demparen != -1) {
        demangled = demangled[0..demparen];
    }
    
    parse_Arguments(node, Dargs, Deargs, Cargs, Dcall, Ccall);
    parse_Function_body(node, safeName(name), mangled, demangled, type,
                        Dargs, Deargs, Cargs, Dcall, Ccall);
}

/**
 * Parse a Constructor node
 */
void parse_Constructor(xmlNode *node)
{
    if (outputC) return; // no constructors in C
    
    char[] name = getNName(node);
    char[] mangled = toString(getMangled(node));
    
    while (find(mangled, "*INTERNAL*") != -1) {
        mangled = replace(mangled, " *INTERNAL* ", "");
    }
    
    char[] Dargs;
    char[] Deargs = "void *This";
    char[] Cargs;
    if (outputC) {
        Cargs = "struct " ~ curClass ~ " *This";
    } else {
        Cargs = curClass ~ " *This";
    }
    char[] Dcall = "__C_data";
    char[] Ccall;
    
    parse_Arguments(node, Dargs, Deargs, Cargs, Dcall, Ccall);
    
    dhead ~= "extern (C) void *_BCD_new_" ~ mangled ~ "(" ~ Deargs ~ ");\n";
    
    dtail ~= "this(" ~ Dargs ~ ") {\n";
    dtail ~= "super(cast(ifloat) 0);\n";
    dtail ~= "__C_data = _BCD_new_" ~ mangled ~ "(" ~ Dcall ~ ");\n";
    dtail ~= "}\n";
    
    cout ~= curClass ~ " *_BCD_new_" ~ mangled ~ "(" ~ Cargs ~ ") {\n";
    cout ~= "return new " ~ curClass ~ "(" ~ Ccall ~ ");\n";
    cout ~= "}\n";
}

/**
 * Parse a Typedef node
 */
void parse_Typedef(xmlNode *node)
{
    static bool[char[]] handledTypedefs;
    
    ParsedType pt = parseType(toString(xmlGetProp(node, "type")), node.parent);
    char[] aname = getNName(node);
    char[] type = toString(xmlGetProp(node, "id"));
    
    if (!(type in handledTypedefs)) {
        handledTypedefs[type] = true;
        
        cout ~= "typedef " ~ pt.CType ~ " _BCD_" ~ aname ~ ";\n";
        
        if (files[toString(xmlGetProp(node, "file"))] == curFile)
            dhead ~= "alias " ~ pt.DType ~ " " ~ aname ~ ";\n";
    }
}

/**
 * Parse an Enumeration node
 */
void parse_Enumeration(xmlNode *node)
{
    static bool[char[]] handledEnums;
    
    char[] aname = getNName(node);
    if (aname == "") return;
    char[] type = toString(xmlGetProp(node, "id"));
    
    // make an enum in D as well
    if (!(type in handledEnums)) {
        handledEnums[type] = true;
        
        if (files[toString(xmlGetProp(node, "file"))] != curFile) return;
        if (aname[0] == '.') return;
        
        dhead ~= "enum " ~ safeName(aname) ~ " {\n";
        
        xmlNode *curNode = null;
        
        for (curNode = node.children; curNode; curNode = curNode.next) {
            if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
                char[] nname = toString(curNode.name);
                
                if (nname == "EnumValue") {
                    dhead ~= safeName(getNName(curNode)) ~ "=" ~
                    toString(xmlGetProp(curNode, "init")) ~ ",\n";
                } else {
                    writefln("I don't know how to parse %s!", nname);
                }
            }
        }
        
        dhead ~= "}\n";
    }
}

/**
 * A type in both C[++] and D
 */
class ParsedType {
    this(char[] sCType, char[] sDType)
    {
        CType = sCType;
        DType = sDType;
    }
    this(ParsedType copy)
    {
        CType = copy.CType;
        DType = copy.DType;
    }
    char[] CType;
    char[] DType;
    char[] className;
    bool isClass;
    bool isClassPtr;
    bool isFunction;
}

/**
 * Get the type of a node in C[++] and D
 */
ParsedType parseType(char[] type, xmlNode *gccxml)
{
    // first find the element matching the type
    xmlNode *curNode = null;
    
    for (curNode = gccxml.children; curNode; curNode = curNode.next) {
        if (curNode.type == xmlElementType.XML_ELEMENT_NODE) {
            char *id = xmlGetProp(curNode, "id");
            if (!id ||
                toString(id) != type) continue;
            
            char[] nname = toString(curNode.name);
            
            if (nname == "FundamentalType") {
                char[] ctype = getNName(curNode);
                switch (ctype) {
                    case "void":
                        return new ParsedType("void", "void");
                        
                        
                    case "long long int":
                        return new ParsedType("long long int", "long");
                        
                    case "long long unsigned int":
                        return new ParsedType("long long unsigned int", "ulong");
                        
                        
                    case "long int":
                        return new ParsedType("long int", "int");
                        
                    case "long unsigned int":
                        return new ParsedType("long unsigned int", "uint");
                        
                        
                    case "int":
                        return new ParsedType("int", "int");
                        
                    case "unsigned int":
                        return new ParsedType("unsigned int", "uint");
                        
                        
                    case "short int":
                        return new ParsedType("short int", "short");
                        
                    case "short unsigned int":
                        return new ParsedType("short unsigned int", "ushort");
                        
                        
                    case "char":
                        return new ParsedType("char", "char");
                        
                    case "signed char":
                        return new ParsedType("signed char", "char");
                        
                    case "unsigned char":
                        return new ParsedType("unsigned char", "char");
                        
                        
                    case "bool":
                        return new ParsedType("bool", "bool");
                        
                        
                    case "long double":
                        return new ParsedType("long double", "real");
                        
                        
                    case "double":
                        return new ParsedType("double", "double");
                        
                        
                    case "float":
                        return new ParsedType("float", "float");
                        
                    default:
                        writefln("I don't know how translate %s to D.", ctype);
                }
                
            } else if (nname == "PointerType") {
                ParsedType baseType =
                    parseType(toString(xmlGetProp(curNode, "type")), gccxml);
                // functions and classes are already pointers
                if (!baseType.isClass && !baseType.isFunction) {
                    baseType.CType ~= " *";
                    baseType.DType ~= " *";
                } else if (baseType.isClass) {
                    ParsedType pt = new ParsedType(baseType);
                    pt.DType ~= " *";
                    pt.isClassPtr = true;
                    return pt;
                }
                
                return new ParsedType(baseType);
             
            } else if (nname == "ArrayType") {
                ParsedType baseType =
                    parseType(toString(xmlGetProp(curNode, "type")), gccxml);
                int size = to!int(toString(xmlGetProp(curNode, "max"))) + 1;
                
                // make a typedef and an alias
                static bool[char[]] handledArrays;
                
                if (!(type in handledArrays)) {
                    handledArrays[type] = true;
                    
                    cout ~= "typedef " ~ baseType.CType ~ " _BCD_array_" ~ type ~
                    "[" ~ toString(size) ~ "];\n";
                }
                
                baseType.CType = "_BCD_array_" ~ type;
                baseType.DType ~= " [" ~ toString(size) ~ "]";
                
                return new ParsedType(baseType);
                
            } else if (nname == "ReferenceType") {
                ParsedType baseType =
                    parseType(toString(xmlGetProp(curNode, "type")), gccxml);
                
                if (!baseType.isClass) {
                    if (outputC) {
                        baseType.CType ~= " *";
                    } else {
                        baseType.CType ~= " &";
                    }
                    baseType.DType ~= " *";
                } else {
                    // we need to treat this as a pointer in D, but a reference in C
                    
                    // 1) cut off the *
                    baseType.CType = baseType.CType[0 .. baseType.CType.length - 2];
                    
                    // 2) add the &
                    if (outputC) {
                        baseType.CType ~= " *";
                    } else {
                        baseType.CType ~= " &";
                    }
                    
                    ParsedType pt = new ParsedType(baseType);
                    pt.isClassPtr = true;
                    return pt;
                }
                
                return new ParsedType(baseType);
                
            } else if (nname == "Struct" || nname == "Class") {
                char[] className = toString(getDemangled(curNode));
                
                if (outputC) {
                    if (xmlGetProp(curNode, "incomplete")) {
                        return new ParsedType("struct " ~ className,
                                              "void");
                    } else {
                        return new ParsedType("struct " ~ className,
                                              safeName(getNName(curNode)));
                    }
                } else {
                    ParsedType pt;
                    
                    // can't have incomplete types in D, so call it a BoundClass in D
                    if (xmlGetProp(curNode, "incomplete")) {
                        pt = new ParsedType(className ~ " *",
                                            "bcd.bind.BoundClass");
                    } else {
                        pt = new ParsedType(className ~ " *",
                                            safeName(getNName(curNode)));
                    }
                    pt.className = className;
                    pt.isClass = true;
                    return pt;
                }
                
            } else if (nname == "Union") {
                char[] className = toString(getDemangled(curNode));
                
                if (xmlGetProp(curNode, "incomplete")) {
                    return new ParsedType("union " ~ className,
                                          "void");
                } else {
                    return new ParsedType("union " ~ className,
                                          safeName(getNName(curNode)));
                }
                
            } else if (nname == "CvQualifiedType") {
                // this is just a const
                ParsedType pt = parseType(toString(xmlGetProp(curNode, "type")), gccxml);
                if (pt.CType.length < 6 ||
                    pt.CType[0..6] != "const ")
                    pt.CType = "const " ~ pt.CType;
                return pt;
                
            } else if (nname == "Typedef") {
                // this is also an alias, but we should replicate it in D
                ParsedType pt = parseType(toString(xmlGetProp(curNode, "type")), gccxml);
                char[] aname = getNName(curNode);
                
                parse_Typedef(curNode);
                
                ParsedType rpt = new ParsedType("_BCD_" ~ aname, pt.DType);
                rpt.isClass = pt.isClass;
                rpt.isFunction = pt.isFunction;
                return rpt;
                
            } else if (nname == "FunctionType") {
                // make a typedef and an alias
                static bool[char[]] handledFunctions;
                
                if (!(type in handledFunctions)) {
                    handledFunctions[type] = true;
                    
                    ParsedType pt = parseType(toString(xmlGetProp(curNode, "returns")), gccxml);
                    char[] couta, dheada;
                    
                    bool first = true;
                    couta = "typedef " ~ pt.CType ~
                    " (*_BCD_func_" ~ type ~ ")(";
                    dheada = "alias " ~ pt.DType ~ " function(";
                    
                    // now look for arguments
                    xmlNode *curArg;
                    for (curArg = curNode.children; curArg; curArg = curArg.next) {
                        if (curArg.type == xmlElementType.XML_ELEMENT_NODE) {
                            char[] aname = toString(curArg.name);
                            
                            ParsedType argType =
                                parseType(toString(xmlGetProp(curArg, "type")), gccxml);
                            
                            if (!first) {
                                couta ~= ", ";
                                dheada ~= ", ";
                            } else {
                                first = false;
                            }
                            
                            couta ~= argType.CType;
                            dheada ~= argType.DType;
                        }
                    }
                    
                    cout ~= couta ~ ");\n";
                    dhead ~= dheada ~ ") _BCD_func_" ~ type ~ ";\n";
                }
                
                ParsedType pt = new ParsedType("_BCD_func_" ~ type, "_BCD_func_" ~ type);
                pt.isFunction = true;
                return pt;
             
            } else if (nname == "Enumeration") {
                parse_Enumeration(curNode);
                
                // if this is fake, ignore it
                char[] aname = getNName(curNode); 
                if (aname[0] == '.') {
                    return new ParsedType("int", "int");
                }
                
                /* we need the demangled name in C, but there is no demangled=
                 * for enumerations, so we need the parent */
                char *context = xmlGetProp(curNode, "context");
                if (context) {
                    char[] scontext = toString(context);
                    xmlNode *pnode;
                    for (pnode = gccxml.children; pnode; pnode = pnode.next) {
                        if (pnode.type == xmlElementType.XML_ELEMENT_NODE) {
                            if (toString(xmlGetProp(pnode, "id")) == scontext) {
                                // FIXME: temporary kludge
                                char[] demangled = toString(getDemangled(pnode));
                                if (demangled != "" && demangled != "::") {
                                    return new ParsedType(
                                        "enum " ~ demangled ~ "::" ~ aname,
                                        "int");
                                }
                            }
                        }
                    }
                }
                
                return new ParsedType("enum " ~ aname, "int");
                
            } else {
                writefln("I don't know how to parse the type %s.", nname);
            }
        }
    }
    
    return new ParsedType("void *", "void *");
}
